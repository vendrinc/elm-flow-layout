[{"name":"Flow","comment":"\n\n\n# Workflow\n\n@docs Flow\n\n\n# Query\n\n@docs getNode\n@docs isSequential, isParallel, isCondition, isEmpty\n@docs descendants, nodes\n@docs leftEdge, rightEdgeNodes, dependencies, dependants\n@docs findNode\n@docs edges\n@docs toDot\n@docs DependencyChange, diff\n@docs breadthFirstFold\n@docs findMap\n\n\n# Update\n\n@docs optimize, sortParallel\n@docs map, mapWithNode, filter\n@docs Step, navigateTo, mapAt, previousPath, nextPath, find\n\n","unions":[{"name":"Flow","comment":" Note that `Sequential []` is our designated \"empty\" node.\n`Parallel []` could fit the same purpose technically but we prefer Sequential.\nWe coerce `Parallel []` into `Sequential []` when running `optimize`.\n\nDESIGN NOTE: Another option would be to have non-empty lists in Sequential and\nParallel and have an explicit `Empty` constructor.\n\n","args":["node"],"cases":[["Node",["node"]],["Sequential",["List.List (Flow.Flow node)"]],["Parallel",["List.List (Flow.Flow node)"]],["Condition",["node","{ trueSeq : List.List (Flow.Flow node), falseSeq : List.List (Flow.Flow node) }"]]]},{"name":"Step","comment":" ","args":[],"cases":[["InSequential",["Basics.Int"]],["InParallel",["Basics.Int"]],["InConditionTrue",["Basics.Int"]],["InConditionFalse",["Basics.Int"]]]}],"aliases":[{"name":"DependencyChange","comment":" ","args":[],"type":"{ task : String.String, newDeps : List.List { branch : Basics.Int, id : String.String }, removeDeps : List.List { branch : Basics.Int, id : String.String } }"}],"values":[{"name":"breadthFirstFold","comment":" Fold by visiting nodes in the same order they would get unblocked.\n\n    0 ──╮── 1 ─── 3 ── 6 ──╭─ 3\n        ╰── 2 ─╮─ 4 ──╭────╯\n               ╰─ 5 ──╯\n\nUnlike parallel tracks, condition branches are visited entirely before the next one.\n\n               ᴛʀᴜᴇ\n    0 ──╮──╮── 1 ─── 3 ── 6 ──╭──╭─── 10\n        │  ╰── 2 ─╮─ 4 ─╭─────╯  │\n        │         ╰─ 5 ─╯        │\n        │      ғᴀʟsᴇ             │\n        ╰──╮── 7 ─── 9 ─╭────────╯\n           ╰── 8 ───────╯\n\n","type":"(a -> b -> b) -> b -> Flow.Flow a -> b"},{"name":"dependants","comment":" ","type":"List.List Flow.Step -> Flow.Flow node -> List.List { path : List.List Flow.Step, node : node, branch : Basics.Int }"},{"name":"dependencies","comment":" ","type":"List.List Flow.Step -> Flow.Flow node -> List.List { node : node, branch : Basics.Int }"},{"name":"descendants","comment":" Returns all recursive children of the Flow (including the input Flow itself),\nin a depth-first traversal.\n\n    Sequential\n        [ Node 1\n        , Parallel\n            [ Node 2\n            , Node 3\n            ]\n        , Condition 4\n            { trueSeq = [ Node 5 ]\n            , falseSeq = [ Node 6 ]\n            }\n        ]\n        |> descendants\n        == [ Sequential [ Node 1, Parallel [ Node 2, Node 3 ], Condition 4 { trueSeq = [ Node 5 ], falseSeq = [ Node 6 ] } ]\n           , Node 1\n           , Parallel [ Node 2, Node 3 ]\n           , Node 2\n           , Node 3\n           , Condition 4 { trueSeq = [ Node 5 ], falseSeq = [ Node 6 ] }\n           , Node 5\n           , Node 6\n           ]\n\n","type":"Flow.Flow node -> List.List (Flow.Flow node)"},{"name":"diff","comment":" ","type":"{ before : Flow.Flow node, after : Flow.Flow node, nodeToId : node -> String.String } -> List.List Flow.DependencyChange"},{"name":"edges","comment":" The `before` and `after` record fields are meant in the workflow sense:\nyou need to first complete the `before` step,\nthen you can complete the `after` step.\n\n     edges (Seq [ Node 0, Node 1 ])\n     -->\n     [ { before = 0, after = 1, branch = 0 } ]\n\n","type":"{ nodeToId : node -> String.String } -> Flow.Flow node -> List.List { before : String.String, after : String.String, branch : Basics.Int }"},{"name":"filter","comment":" Keeping nodes satisfying a predicate\n","type":"(a -> Basics.Bool) -> Flow.Flow a -> Flow.Flow a"},{"name":"find","comment":" ","type":"(Flow.Flow node -> Basics.Bool) -> Flow.Flow node -> Maybe.Maybe ( Flow.Flow node, List.List Flow.Step )"},{"name":"findMap","comment":" ","type":"(Flow.Flow node -> Maybe.Maybe a) -> Flow.Flow node -> Maybe.Maybe ( a, List.List Flow.Step )"},{"name":"findNode","comment":" ","type":"(a -> Maybe.Maybe b) -> Flow.Flow a -> Maybe.Maybe b"},{"name":"getNode","comment":" ","type":"Flow.Flow node -> Maybe.Maybe node"},{"name":"isCondition","comment":" ","type":"Flow.Flow node -> Basics.Bool"},{"name":"isEmpty","comment":" ","type":"Flow.Flow node -> Basics.Bool"},{"name":"isParallel","comment":" ","type":"Flow.Flow node -> Basics.Bool"},{"name":"isSequential","comment":" ","type":"Flow.Flow node -> Basics.Bool"},{"name":"leftEdge","comment":" ","type":"Flow.Flow node -> List.List { path : List.List Flow.Step, node : node }"},{"name":"map","comment":" Apply a function to every node.\n","type":"(a -> b) -> Flow.Flow a -> Flow.Flow b"},{"name":"mapAt","comment":" ","type":"List.List Flow.Step -> (Flow.Flow node -> Flow.Flow node) -> Flow.Flow node -> Flow.Flow node"},{"name":"mapWithNode","comment":" Apply a function to every node, having acces to the Flow value itself.\n","type":"(Flow.Flow a -> a -> b) -> Flow.Flow a -> Flow.Flow b"},{"name":"navigateTo","comment":" ","type":"List.List Flow.Step -> Flow.Flow node -> Maybe.Maybe (Flow.Flow node)"},{"name":"nextPath","comment":" ","type":"List.List Flow.Step -> Flow.Flow node -> Maybe.Maybe (List.List Flow.Step)"},{"name":"nodes","comment":" ","type":"Flow.Flow node -> List.List ( node, List.List Flow.Step )"},{"name":"optimize","comment":" OPTIMIZE: apply simplifications until you reach a fixpoint.\nThis uses a library Janiczek/transform that handles that fixpoint boilerplate.\n","type":"Flow.Flow node -> Flow.Flow node"},{"name":"previousPath","comment":" ","type":"List.List Flow.Step -> Maybe.Maybe (List.List Flow.Step)"},{"name":"rightEdgeNodes","comment":" Collect the right-most nodes.\n","type":"Flow.Flow node -> List.List node"},{"name":"sortParallel","comment":" ","type":"{ toPosition : node -> comparable } -> Flow.Flow node -> Flow.Flow node"},{"name":"toDot","comment":" ","type":"{ nodeToId : node -> String.String } -> Flow.Flow node -> String.String"}],"binops":[]},{"name":"Flow.Layout","comment":"\n\n@docs Layout\n@docs layout\n@docs Pos\n@docs Config, NodeProperties, ConnectionEnding\n@docs Box\n@docs ConditionRoot\n@docs mapNodes\n\n@docs Size\n\n","unions":[{"name":"ConnectionEnding","comment":" Connections are not only drawn between nodes but also branch endings.\n\nIf a branch starts or ends with a parallel, we do not want\neach of the tracks to connect to the condition node directly:\n\n                  True\n    Condition ──╮────── A\n                │\n                │ False\n                ├────── B\n                │\n                ╰────── C\n\nInstead we want the condition to connect to an \"ending\" that represents\nthe start of the branch and from which each parallel track starts:\n\n                  True\n    Condition ──╮────── A\n                │\n                │ False\n                ╰──┬─── B\n                   │\n                   ╰─── C\n\nThis step is only necessary if either of the branch endings are parallel.\n\n","args":["node"],"cases":[["BranchStart",[]],["BranchEnd",[]],["CNode",["node"]]]}],"aliases":[{"name":"Box","comment":" ","args":[],"type":"{ x : Basics.Int, y : Basics.Int, width : Basics.Int, height : Basics.Int, connectionY : Basics.Int, marginBoxX : Basics.Int }"},{"name":"ConditionRoot","comment":" ","args":["node"],"type":"{ condition : node, branch : Basics.Bool, box : Flow.Layout.Box }"},{"name":"Config","comment":" ","args":["node"],"type":"{ nodeProperties : node -> Flow.Layout.NodeProperties, connectionY : Flow.Layout.ConnectionEnding node -> Basics.Int, gapX : Basics.Int, gapY : Basics.Int, conditionBranchGapX : Basics.Int, conditionBranchGapY : Basics.Int, isConditionRoot : node -> Basics.Bool }"},{"name":"Layout","comment":" ","args":["node"],"type":"{ nodes : List.List ( node, Flow.Layout.Box ), connections : List.List ( Flow.Layout.ConnectionEnding node, Flow.Line.Path, Flow.Layout.ConnectionEnding node ), conditionRoots : List.List (Flow.Layout.ConditionRoot node), size : Flow.Layout.Size, left : List.List ( Flow.Layout.ConnectionEnding node, Flow.Layout.Box ), right : List.List ( Flow.Layout.ConnectionEnding node, Flow.Layout.Box ) }"},{"name":"NodeProperties","comment":" ","args":[],"type":"{ width : Basics.Int, height : Basics.Int, marginLeft : Basics.Int, marginRight : Basics.Int }"},{"name":"Pos","comment":" ","args":[],"type":"{ x : Basics.Int, y : Basics.Int }"},{"name":"Size","comment":" ","args":[],"type":"{ width : Basics.Int, height : Basics.Int }"}],"values":[{"name":"layout","comment":" Compute a Layout from a Flow tree.\n","type":"Flow.Layout.Pos -> Flow.Layout.Config node -> Flow.Flow node -> Flow.Layout.Layout node"},{"name":"mapNodes","comment":" Apply a function to every node in the layout.\n","type":"(a -> b) -> Flow.Layout.Layout a -> Flow.Layout.Layout b"}],"binops":[]},{"name":"Flow.Line","comment":"\n\n@docs Path, Point, Stroke\n\n@docs toCommands, view\n\n","unions":[{"name":"Path","comment":" ","args":[],"cases":[["Horizontal",["Flow.Line.Point","List.List Flow.Line.Point","Flow.Line.Point"]],["Vertical",["Flow.Line.Point","Flow.Line.Point"]]]},{"name":"Stroke","comment":" ","args":[],"cases":[["Dashed",["Basics.Int"]],["Solid",[]]]}],"aliases":[{"name":"Point","comment":" ","args":[],"type":"{ x : Basics.Int, y : Basics.Int }"}],"values":[{"name":"toCommands","comment":" ","type":"Basics.Int -> Flow.Line.Path -> String.String"},{"name":"view","comment":" ","type":"List.List (Svg.Attribute msg) -> { stroke : Flow.Line.Stroke, strokeWidth : Basics.Int, strokeColor : Maybe.Maybe String.String, cornerRadius : Basics.Int } -> Flow.Line.Path -> Html.Html msg"}],"binops":[]},{"name":"Flow.Operation","comment":"\n\n@docs Operation, applyAt\n@docs Config\n\n","unions":[{"name":"Operation","comment":" Allowed positions:\n\n  - AddBefore: anywhere\n  - AddAfter: anywhere\n  - AddParallelBelow: anywhere\n  - ReattachFalseInsideCondition: on Condition\n  - ReattachFalseOutsideCondition: on Condition\n  - Remove: anywhere\n\n","args":["node"],"cases":[["AddBefore",["{ isCondition : Basics.Bool }","node"]],["AddAfter",["{ isCondition : Basics.Bool }","node"]],["AddParallelBelow",["{ isCondition : Basics.Bool }","node"]],["ReattachFalseInsideCondition",["{ index : Basics.Int }"]],["ReattachFalseOutsideCondition",["{ index : Basics.Int }"]],["Remove",[]]]}],"aliases":[{"name":"Config","comment":" ","args":["node"],"type":"{ toId : node -> String.String }"}],"values":[{"name":"applyAt","comment":" `applyAt` assumes you'll later run `optimize` to flatten out nested\nSequentials and Parallels.\n\nTODO: when we see the usage in some kind of `update` function, decide\nwhether we should call `optimize` here implicitly and remove the above\ncomment, or whether to let the user decide when to optimize.\n\n","type":"Flow.Operation.Config node -> List.List Flow.Step -> Flow.Operation.Operation node -> Flow.Flow node -> Maybe.Maybe ( Flow.Flow node, List.List Flow.DependencyChange )"}],"binops":[]},{"name":"Flow.Viewer","comment":"\n\n@docs Model, Msg\n@docs init, update, subscriptions\n@docs focusOn, focusOnWith\n@docs seeAll, seeAllWith\n@docs setOffset, Offset\n@docs zoomCenter\n@docs withTransitions\n@docs setViewportBox\n@docs setLayout\n@docs view, BranchLabel, Lazy, Lazy4\n@docs viewSolidConnection\n@docs cssNodeId, cssBranchLabelId\n@docs toViewportCoords\n\n@docs resizeMsgBox, MeasureState\n\n","unions":[{"name":"MeasureState","comment":" ","args":[],"cases":[]},{"name":"Msg","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"BranchLabel","comment":" ","args":["msg"],"type":"{ view : Html.Html msg, offsetY : Basics.Int }"},{"name":"Lazy","comment":" ","args":["a","r"],"type":"{ fn : a -> r, a : a }"},{"name":"Lazy4","comment":" ","args":["a","b","c","d","r"],"type":"{ fn : a -> b -> c -> d -> r, a : a, b : b, c : c, d : d }"},{"name":"Model","comment":" ","args":["node"],"type":"{ zoom : Basics.Float, offset : Flow.Viewer.Offset, viewportBox : Flow.Viewer.MeasureState, panning : Basics.Bool, layout : Flow.Layout.Layout ( String.String, node ), transitions : Basics.Bool }"},{"name":"Offset","comment":" ","args":[],"type":"{ x : Basics.Float, y : Basics.Float }"}],"values":[{"name":"cssBranchLabelId","comment":" Get the full id of a branch label to target it in a CSS stylesheet\n","type":"{ viewerId : String.String, nodeId : String.String, branch : Basics.Bool } -> String.String"},{"name":"cssNodeId","comment":" Get the full id of a specific node to target it in a CSS stylesheet.\n","type":"{ viewerId : String.String, nodeId : String.String } -> String.String"},{"name":"focusOn","comment":" Center on a specific node by id. Zoom remains the same.\n","type":"{ id : String.String } -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"focusOnWith","comment":" ","type":"{ id : String.String, onlyHorizontally : Basics.Bool, offsetX : Basics.Int, offsetY : Basics.Int } -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"init","comment":" ","type":"{ toId : node -> String.String, viewportBox : Maybe.Maybe Flow.Viewer.Box } -> Flow.Layout.Layout node -> Flow.Viewer.Model node"},{"name":"resizeMsgBox","comment":" ","type":"Flow.Viewer.Msg -> Maybe.Maybe Flow.Viewer.Box"},{"name":"seeAll","comment":" Center and zoom as much as necessary to fit the whole content if possible.\n","type":"Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"seeAllWith","comment":" ","type":"{ bounded : Basics.Bool, offsetY : Basics.Float } -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"setLayout","comment":" Update layout but keep the same zoom and offset.\n","type":"{ toId : node -> String.String, layout : Flow.Layout.Layout node } -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"setOffset","comment":" Set the viewport offset relative to layout dimensions.\n\nValues are limited to the middle point of the viewport to prevent users from scrolling away completely.\n\n","type":"Flow.Viewer.Offset -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"setViewportBox","comment":" Set viewport box explicitly.\n\nNote: Resizes will override this.\n\n","type":"Flow.Viewer.Box -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"subscriptions","comment":" ","type":"Flow.Viewer.Model node -> (Flow.Viewer.Msg -> msg) -> Maybe.Maybe (Basics.Int -> Basics.Int -> Json.Decode.Decoder msg) -> Platform.Sub.Sub msg"},{"name":"toViewportCoords","comment":" Convert page coords to viewport coords according to zoom and offset\n","type":"Flow.Viewer.Model node -> Basics.Float -> Basics.Float -> { x : Basics.Int, y : Basics.Int }"},{"name":"update","comment":" ","type":"Flow.Viewer.Msg -> Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"view","comment":" ","type":"{ id : String.String, model : Flow.Viewer.Model node, toMsg : Flow.Viewer.Msg -> msg, viewNode : Flow.Viewer.Lazy4 na nb nc nd (( String.String, node ) -> Flow.Layout.Box -> Html.Html msg), viewBranchLabel : node -> Basics.Bool -> Maybe.Maybe (Flow.Viewer.BranchLabel msg), viewConnection : Flow.Viewer.Lazy ca (Flow.Layout.ConnectionEnding ( String.String, node ) -> Flow.Layout.ConnectionEnding ( String.String, node ) -> Flow.Line.Path -> Html.Html msg), scaledSvgExtra : Maybe.Maybe (List.List (Html.Html msg)) } -> Html.Html msg"},{"name":"viewSolidConnection","comment":" ","type":"Flow.Line.Path -> Html.Html msg"},{"name":"withTransitions","comment":" Transition to new offset or zoom level.\n","type":"Flow.Viewer.Model node -> Flow.Viewer.Model node"},{"name":"zoomCenter","comment":" Set the zoom level while focusing on the center of the viewport.\n","type":"(Basics.Float -> Basics.Float) -> Flow.Viewer.Model node -> Flow.Viewer.Model node"}],"binops":[]}]